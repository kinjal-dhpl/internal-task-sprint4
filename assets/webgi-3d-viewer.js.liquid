
import {
  ViewerApp, //  main app that creates and controls the 3D viewer on the page
  addBasePlugins, // Importing base plugins ( lighting,camera controls,etc )
  PickingPlugin, // lets you click/select objects in 3D.
  DiamondPlugin, // adds special rendering for diamond-like materials.
  AssetManagerPlugin,
  Mesh,
  MaterialConfiguratorPlugin,
  EquirectangularReflectionMapping,
  CanvasSnipperPlugin, // lets you take a snapshot of the 3D view as an image.
  FileTransferPlugin, // used to export or transfer files.
  Object3D, // geometry and material helpers.
  Material,
  Vector3,
  Vector2, // geometry and material helpers.
  Texture,
  sRGBEncoding, //geometry and material helpers.
  // ...
} from "https://dist.pixotronics.com/webgi/runtime/bundle-0.11.0.mjs";

window.CanvasSelectedMaterials = {};

document.addEventListener(
  "DOMContentLoaded",
  (x) => {
    console.log("DOM loaded once===========================");
    function getColor(colorName) {
      const map = {
        "Yellow": "#E8C547",
        "White": "#DADADA",
        "Rose": "#E5A3A3",
        "Champagne": "#C7B199",
        "Polished": "#bcbcbc",
        "Matte": "#999999",
        "Horizontal Velvet": "#888",
        "Vertical Satin": "#777",
      };

      return map[colorName] || "#000";
    }


    async function intialize3D() {
      console.log(
        "INIT 3D==========",
        document.querySelectorAll(
          ".canvas-3d-container .customContextGridItems"
        )
      );
      /**
       * STEP 1: This starts a new WebGi viewer and connects it to your <canvas> element.
       *  Everything 3D will be drawn inside that canvas.
       *  */
      const viewer = new ViewerApp({
        canvas: document.getElementById("main-canvas"),
      });

      //Just adding some plugins
      await addBasePlugins(viewer);
      await viewer.addPlugin(DiamondPlugin);

      viewer.renderer.refreshPipeline();

      const productGlbFile = productGlbUrl;
      console.log("productGlbFile", productGlbFile);

      // Default layer definitions. Define all your layers here. Edit this structure to apply your own layer naming and materials
      const defaultLayerConfig = {
        "Metal 01": "yellow-gold-polish.pmat",
        "Metal 02": "yellow-gold-polish.pmat",
        "Metal 03": "yellow-gold-polish.pmat",
      };

      const baseURL = "https://cdn.shopify.com/s/files/1/0664/3780/8182/files/";

      // used for storing materials for each diamond layer
      const layerMaterialMap = {};

      async function getOrCreateMaterial(layerName, matName) {
        console.log("ðŸš€ ~ getOrCreateMaterial ~ matName:", matName)
        console.log("ðŸš€ ~ getOrCreateMaterial ~ layerName:", layerName)
        let material = layerMaterialMap[matName];
        if (material !== undefined) {
          return material;
        } else {
          const matURL = baseURL + matName;
          if (matURL !== undefined) {
            material = await viewer.load(matURL);
            material.name = matName;
            layerMaterialMap[matName] = material;
            return material;
          } else {
            console.warn("Unable to find material for layer ", layerName);
          }
        }
      }

      async function applyMaterialToLayer(layerName, material) {
        const manager = viewer.getManager();

        const materials = manager.materials.findMaterialsByName(layerName);

        if (materials && materials.length > 0) {
          manager.materials.applyMaterial(material, layerName);
        } else {
          console.warn("Unable to find matching materials in Layers");
        }
      }

      async function applyLayerConfig(layerConfig) {
        for (let layerName in layerConfig) {
          const matName = layerConfig[layerName];
          const material = await getOrCreateMaterial(layerName, matName);

          applyMaterialToLayer(layerName, material);
          //  console.log(layerName, matName, material)
        }
      }

      // Loads a 3d model, with auto scaling, and centering.
      async function loadModel(url) {
        const model = await viewer.load(url, {
          autoScale: true,
          autoCenter: true,
        });
        return model;
      }

      await loadModel(
        "https://cdn.shopify.com/3d/models/edeaa3dd5bf5f97e/33.glb" //config 13
        // "https://cdn.shopify.com/3d/models/5b2acaf4e6375be3/R-0009-F2-RENDER_glb.glb" // config 22
        // "https://cdn.shopify.com/3d/models/06c4020a82b8af36/withNewLayerNames.glb"
        // "https://cdn.shopify.com/3d/models/1da2cd695bb73afd/R-0597-WS2-RENDER_glb.glb"
      );

      const onClickColor = async (event) => {
        const name = event.target.getAttribute("mat-name").toLowerCase();
        const layerName = event.target.layer;
        event.preventDefault();
        event.stopPropagation();
        event.target.parentElement
          .querySelectorAll(".customContextGridItems.material-option-active")
          .forEach((el) => {
            el.classList.remove("material-option-active");
          });

        event.target.classList.add("material-option-active");
        let layerConfig = {};
        if (layerName === "Metal 01" || layerName === "Metal 02") {
          const currentConfigType =
            event.target.parentElement.getAttribute("config-type");
          const otherSelected = document
            .querySelector(
              `[layer-name="${layerName}"][config-type="${currentConfigType === "color" ? "finish" : "color"
              }"] .material-option-active`
            )
            ?.getAttribute("mat-name");

          const color = currentConfigType === "color" ? name : otherSelected;
          const finish = currentConfigType === "finish" ? name : otherSelected;

          const materialName = `${color}-${finish}.pmat`;
          layerConfig[layerName] = materialName;
        }

        if (layerName === "Metal 03") {
          layerConfig[layerName] = `${name}-polish.pmat`;
        }
        applyLayerConfig(layerConfig);
        viewer.renderer.refreshPipeline();
      };

      const configuratorDiv = document.getElementById("mconfigurator");
      configuratorDiv.innerHTML = "";

      const allMaterialConfig = [
        {
          name: "Metal Tone 1",
          layerName: "Metal 01",
          configType: "color",
          toBeShownIn: [
            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
            20, 21, 22, 23, 24,
          ],
          options: [
            {
              optionName: "Yellow",
              matName: "yellow-gold",
              colorName: "yellow-gold"
            },
            {
              optionName: "White",
              matName: "white-gold",
              colorName: "white-gold"
            },
            {
              optionName: "Rose",
              matName: "rose-gold",
              colorName: "rose-gold"
            },
            {
              optionName: "Champagne",
              matName: "champagne",
              colorName: "champagne"
            },
          ],
        },
        {
          name: "Metal Tone 2",
          layerName: "Metal 02",
          configType: "color",
          toBeShownIn: [
            4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
          ],
          options: [
            {
              optionName: "Yellow",
              matName: "yellow-gold",
              colorName: "yellow-gold"
            },
            {
              optionName: "White",
              matName: "white-gold",
              colorName: "white-gold"
            },
            {
              optionName: "Rose",
              matName: "rose-gold",
              colorName: "rose-gold"
            },
            {
              optionName: "Champagne",
              matName: "champagne",
              colorName: "champagne"
            },
          ],
        },
        {
          name: "Prong Rhodium",
          layerName: "Metal 03",
          configType: "color",
          toBeShownIn: [13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24],
          options: [
            {
              optionName: "Yellow",
              matName: "yellow-gold",
              colorName: "yellow-gold"
            },
            {
              optionName: "White",
              matName: "white-gold",
              colorName: "white-gold"
            },
            {
              optionName: "Rose",
              matName: "rose-gold",
              colorName: "rose-gold"
            },
            {
              optionName: "Champagne",
              matName: "champagne",
              colorName: "champagne"
            },
          ],
        },
        {
          name: "Metal Finish 1",
          layerName: "Metal 01",
          configType: "finish",
          toBeShownIn: [
            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
            20, 21, 22, 23, 24,
          ],
          options: [
            {
              optionName: "Polished",
              matName: "polish",
              toBeShownIn: [
                1, 3, 4, 5, 8, 9, 11, 12, 13, 14, 17, 18, 20, 21, 22, 24,
              ],
            },
            {
              optionName: "Matte",
              matName: "matte",
              toBeShownIn: [
                2, 3, 6, 7, 9, 10, 11, 12, 15, 16, 18, 19, 20, 21, 23, 24,
              ],
            },
            {
              optionName: "Horizontal Velvet",
              matName: "hori-velvet",
              toBeShownIn: [3, 9, 11, 12, 18, 20, 21, 24],
            },
            {
              optionName: "Vertical Satin",
              matName: "vert-satin",
              toBeShownIn: [3, 9, 11, 12, 18, 20, 21, 24],
            },
          ],
        },
        {
          name: "Metal Finish 2",
          layerName: "Metal 02",
          configType: "finish",
          toBeShownIn: [
            4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
          ],
          options: [
            {
              optionName: "Polished",
              matName: "polish",
              toBeShownIn: [4, 6, 8, 9, 10, 11, 13, 15, 17, 18, 19, 20, 21],
            },
            {
              optionName: "Matte",
              matName: "matte",
              toBeShownIn: [5, 7, 8, 9, 10, 12, 14, 16, 17, 18, 19, 21],
            },
            {
              optionName: "Horizontal Velvet",
              matName: "hori-velvet",
              toBeShownIn: [8, 9, 10, 17, 18, 19],
            },
            {
              optionName: "Vertical Satin",
              matName: "vert-satin",
              toBeShownIn: [8, 9, 10, 17, 18, 19],
            },
          ],
        },
      ];

      const scenarioTag = 18; // Change this value to test different scenarios

      const filteredMaterialConfig = allMaterialConfig.filter((config) =>
        config.toBeShownIn.includes(scenarioTag)
      );

      for (let i = 0; i < filteredMaterialConfig.length; i++) {
        const { name, layerName, configType, options } =
          filteredMaterialConfig[i];
        const container = document.createElement("div");
        container.classList.add("variations", "customContextGrid");
        container.setAttribute(
          "style",
          "top: 20px; left: 20px; gap: 0.25rem; width: 13.5rem;"
        );

        container.setAttribute("layer-name", layerName);
        container.setAttribute("config-type", configType);
        const headingContainer = document.createElement("div");
        headingContainer.classList.add("customContextGridHeading");
        headingContainer.textContent = name;
        container.appendChild(headingContainer);
        configuratorDiv.appendChild(container);
        const filterContainer = document.createElement("div");
        filterContainer.classList.add('customContextGridItemsContainer')
        filterContainer.setAttribute("style", "display: flex; align-items: center; gap: 20px; flex-wrap: wrap;")

        const filteredOptions = options.filter((option) => {
          if (option.toBeShownIn) {
            return option.toBeShownIn.includes(scenarioTag);
          }
          return true;
        });

        for (let j = 0; j < filteredOptions.length; j++) {
          const button = document.createElement("div");
          button.classList.add("customContextGridItems");
          button.setAttribute("style", "width: 2.5rem; height: 2.5rem;");
          if (j === 0) {
            button.classList.add("material-option-active");
          }
          const { optionName, matName, colorName } = filteredOptions[j];
          if (colorName) {
            const colorDiv = document.createElement('div')
            colorDiv.setAttribute('style', `background: ${getColor(optionName)}; display: block !important; width: 15px; height: 15px; border-radius: 100%;`)
            colorDiv.classList.add('color-div')
            button.append(colorDiv);
          }
          const oName = document.createElement('p')
          oName.innerText = optionName
          button.append(oName);
          button.setAttribute("mat-name", matName);
          button.layer = layerName;
          button.onclick = onClickColor;
          filterContainer.append(button);
        }
        container.append(filterContainer)
      }

      const snipper = await viewer.addPlugin(CanvasSnipperPlugin); // CanvasSnipperPlugin lets you take screenshots.
      await viewer.addPlugin(FileTransferPlugin); // FileTransferPlugin allows saving/exporting files.

      // Apply default layers
      await applyLayerConfig(defaultLayerConfig);

      // Loads a preset configuration that defines camera angles, lighting setups, and material mappings â€” basically, how the scene should look once loaded.
      await viewer.load(
        "https://cdn.shopify.com/s/files/1/0664/3780/8182/files/scene-config.vjson?v=1760428706"
      );

      document
        .querySelector('[data-action="save-personalization"]')
        .addEventListener("click", async () => {
          try {
            // loader overlay
            const personalizationImageCaptureEl = document.querySelector(
              "#personalization-loader-overlay"
            );
            personalizationImageCaptureEl.classList.add("custom_active"); // add loader
            delete pdpSelectedFormOptions.personalize; // delete previous entry if any
            // Define the 5 viewpoints (Y-up world)
            const views = [
              { name: "top", u: { x: 0, y: 1, z: 0 } }, // +Y
              { name: "bottom", u: { x: 0, y: -1, z: 0 } }, // -Y
              { name: "left", u: { x: -1, y: 0, z: 0 } }, // -X
              { name: "right", u: { x: 1, y: 0, z: 0 } }, // +X
              // front-top-right: diagonal (+X, +Y, +Z).
              // If your "front" is -Z, flip z: {z: -1}
              { name: "ftr", u: { x: 1, y: 1, z: 1 } },
            ];

            const files = [];
            for (const v of views) {
              await moveCameraByUnitOffset(viewer, v.u);
              const file = await captureFile(snipper, `ring-${v.name}.webp`);
              const data = {
                fieldName: "files",
                blob: file,
                filename: v.name,
              };
              files.push(data);

              // OPTIONAL: download for quick manual verification
              // downloadBlobFile(file, `ring-${v.name}.webp`);
            }

            // yahan close kara sakte ho modal
            const personalizationSummaryEl = document.getElementById(
              "personalization-summary"
            );
            const personalizationSummaryData =
              personalizationSummaryEl.querySelector(".summary-details");
            const personalizationModalTriggeringInputEl =
              document.getElementById("personalization-options");
            const personalizationImagesDataEl =
              personalizationSummaryEl.querySelector(".ring-thumbnails");
            let SelectedMaterials = Array.from(
              document.getElementById("mconfigurator").children
            ).map((child) => {
              const title = child.querySelector(
                ".customContextGridHeading"
              ).innerText;
              const materialName = child.querySelector(
                ".customContextGridItems.material-option-active"
              ).innerText;
              return { title, materialName };
            });
            if (
              SelectedMaterials &&
              personalizationSummaryEl &&
              personalizationModalTriggeringInputEl
            ) {
              let personalizedSummaryHtml = "";
              // create html
              SelectedMaterials.forEach((selection, index) => {
                let metalTitle = selection.title;
                let metalName = selection.materialName;
                personalizedSummaryHtml += `
              <div class="summary-item">
                <span class="summary-label">${metalTitle}:</span>
                <span class="summary-value" id="summary-metal-tone-${index + 1
                  }">${metalName}</span>
              </div>
              `;
              });
              // end

              personalizationSummaryData.innerHTML = personalizedSummaryHtml;

              personalizationSummaryEl.setAttribute("selected", "true");
              personalizationSummaryEl.classList.remove("hidden");
              personalizationModalTriggeringInputEl.classList.add("hidden");
              document.querySelector(
                "#no-personalization-radio"
              ).checked = false;
            }

            function closeModal() {
              const modal = document.getElementById("personalization-modal");
              modal.classList.remove("active");
              document.body.style.overflow = ""; // Restore scrolling
            }

            const uploadResult = await uploadBlobs(
              `${window.EA_MODULE_BASE_URL}/internal/upload-files`,
              files
            );
            closeModal();

            // Update final summary if visible
            const finalSummaryForm =
              document.getElementById("final-summary-form");
            if (
              finalSummaryForm &&
              !finalSummaryForm.classList.contains("hidden")
            ) {
              updateFinalSummary();
            }

            personalizationImageCaptureEl.classList.remove("custom_active"); // remove loader

            // update images on form bottom
            let personalizationImages = uploadResult.data.fileUrls;
            let uploadedImagesHtml = "";

            // Loop through each uploaded image URL
            personalizationImages.forEach((imgLink, index) => {
              uploadedImagesHtml += `
              <div class="ring-thumbnail">
                <img src="${imgLink}" alt="Ring View">
              </div>
              <input type="hidden" name="properties[personalization image ${index + 1
                }]" value="${imgLink}">
            `;
            });
            // Render all HTML inside your form container
            personalizationImagesDataEl.innerHTML = uploadedImagesHtml;
            // Show engraving form
            const engravingForm = document.getElementById("engraving-form");
            if (engravingForm) engravingForm.classList.remove("hidden");

            const personalizationPDPformEl =
              personalizationSummaryEl.closest(".pdp-form");

            // enable next form ( engraving )
            enableNextForm(personalizationPDPformEl);

            // const file = await snipper.getFile('snapshot.webp');
            // files.push(file);

            // await injectCapturedFiles(files);

            // At this point `files` is an array of 5 Blobs ready for upload to GCS.
          } catch (e) {
            console.error("Batch capture failed:", e);
            alert(e?.message || "Batch capture failed");
          }
        });
    }

    intialize3D();
  },
  { once: true }
);

// Moves camera to target + (unitOffset * distance) and snaps a fresh frame
async function moveCameraByUnitOffset(viewer, unitOffset /* {x,y,z} */) {
  const cam = viewer.scene.activeCamera; // CameraController
  const ctrl = cam.controls; // OrbitControls
  const threeCam =
    (ctrl && ctrl.object) ||
    cam._threeCamera ||
    cam._camera?.threeObject ||
    cam._camera;

  // Read target (fallback origin)
  let tx = 0,
    ty = 0,
    tz = 0;
  if (ctrl?.target) {
    tx = ctrl.target.x;
    ty = ctrl.target.y;
    tz = ctrl.target.z;
  } else if (cam._target) {
    tx = cam._target.x;
    ty = cam._target.y;
    tz = cam._target.z;
  }

  // Current cam position (from threeCam or controller)
  const p = threeCam?.position || cam._position || { x: 0, y: 6, z: 6 };
  const dx = p.x - tx,
    dy = p.y - ty,
    dz = p.z - tz;
  const dist = Math.max(0.1, Math.hypot(dx, dy, dz));

  // Normalize the unit offset in case it isn't unit length
  const len = Math.max(
    1e-6,
    Math.hypot(unitOffset.x, unitOffset.y, unitOffset.z)
  );
  const ux = unitOffset.x / len,
    uy = unitOffset.y / len,
    uz = unitOffset.z / len;

  // New absolute position
  const nx = tx + ux * dist;
  const ny = ty + uy * dist;
  const nz = tz + uz * dist;

  // Apply (disable damping for instant commit)
  const prevDamping = !!ctrl?.enableDamping;
  if (ctrl) ctrl.enableDamping = false;

  if (ctrl?.target?.set) ctrl.target.set(tx, ty, tz);
  if (cam._target?.set) cam._target.set(tx, ty, tz);

  if (threeCam?.position?.set) threeCam.position.set(nx, ny, nz);
  if (cam._position?.set) cam._position.set(nx, ny, nz);

  threeCam?.lookAt?.(tx, ty, tz);
  cam.autoLookAtTarget = true;
  cam.setDirty?.();
  ctrl?.update?.();

  await viewer.renderer?.refreshPipeline?.();
  await new Promise(requestAnimationFrame);

  if (ctrl) ctrl.enableDamping = prevDamping;
}

async function captureFile(
  snipper,
  name,
  { mimeType = "image/webp", scale = 1.5, dpr = window.devicePixelRatio } = {}
) {
  return snipper.getFile(name, { mimeType, scale, displayPixelRatio: dpr });
}

// quick local verify (optional)
function downloadBlobFile(file, filename) {
  const url = URL.createObjectURL(file);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename || file.name || "snapshot.webp";
  a.click();
  URL.revokeObjectURL(url);
}

async function injectCapturedFiles(files) {
  // files = array of File or Blob objects (like from snipper.getFile)
  const input = document.getElementById("custom-image-top");

  if (!input) return;

  // Create a DataTransfer object (acts like a drag-and-drop payload)
  const dt = new DataTransfer();

  // If your Blob is not already a File, wrap it as one
  files.forEach((blob, i) => {
    const file =
      blob instanceof File
        ? blob
        : new File([blob], `capture-${i + 1}.webp`, {
          type: blob.type || "image/webp",
        });
    dt.items.add(file);
  });

  // Assign the FileList to the input element
  input.files = dt.files;

  // Trigger a 'change' event so any upload handler reacts
  input.dispatchEvent(new Event("change", { bubbles: true }));
}

async function uploadBlobs(url, files, additionalData = {}) {
  const formData = new FormData();

  formData.append("files", files[0].blob, "ring-top.webp");
  formData.append("files", files[1].blob, "ring-left.webp");
  formData.append("files", files[2].blob, "ring-bottom.webp");
  formData.append("files", files[3].blob, "ring-right.webp");
  formData.append("files", files[4].blob, "ring-ftr.webp");

  try {
    const response = await fetch(url, {
      method: "POST",
      body: formData,
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(
        `HTTP error! status: ${response.status}, message: ${errorText}`
      );
    }

    const result = await response.json();
    return result;
  } catch (error) {
    console.error("Error uploading blobs:", error);
    throw error;
  }
}
